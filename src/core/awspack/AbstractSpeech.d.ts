import { Deferred } from '@core/Deferred';
import { TextToSpeechFeature } from '@core/awspack/TextToSpeechFeature';

/**
 * Class that can play back audio generated by AWS Polly and synchronized emit
 * speechmark messages.
 *
 * @abstract
 *
 * @property {TextToSpeechFeature} _speaker - The feature that owns the Speech and will emit speechmark messages.
 * @property {Object[]} _speechmarks -  An array of speechmark objects representing the text and timing of the speech.
 * @property {number} _speechmarkOffset - Speechmark Offset.
 * @property {string} _text - The text of the speech.
 * @property {number} _startTime - Start Time.
 * @property {number} _endTime - End Time.
 * @property {number} _localTime - Local Time.
 * @property {number} _pauseTime - Pause Time.
 * @property {boolean} _playing - Is playing.
 * @property {any} _markIter - Mark Iter.
 * @property {any} _currentMark - Current Mark.
 * @property {any} _done - Done.
 * @property {Deferred} _promise - Promise.
 * @property {any} value - Value.
 * @property {any} done - Done.
 */
export class AbstractSpeech {
  // TODO: Is this really abstract?
  // export abstract class AbstractSpeech {
  // TODO: Make private, add getters
  // public _speaker: TextToSpeechFeature | Messenger;
  public _speaker: any; // Fix circular dependency issues - https://medium.com/visual-development/how-to-fix-nasty-circular-dependency-issues-once-and-for-all-in-javascript-typescript-a04c987cf0de

  public _text: string;
  public _speechmarks: any[];
  public _speechmarkOffset: number;
  public _startTime: number;
  public _localTime: number;
  public _pauseTime: number;
  public _playing: boolean;
  public _markIter: any;
  public _currentMark: any;
  public _endTime: number;
  public _done: any;
  public _promise: Deferred; // Deferred | null;
  public value: any;
  public done: any;

  /**
   * @constructor
   *
   * @param {TextToSpeechFeature} speaker - The feature that owns the Speech and will emit speechmark messages.
   * @param {string} text - The text of the speech.
   * @param {Array.<Object>} [speechmarks=[]] - An array of speechmark objects representing the text and timing of the speech.
   */
  constructor(speaker: any, text: string, speechmarks: any[] = []);

  /**
   * Reset tracking properties.
   *
   * @private
   *
   * @param {number} [currentTime=0] - Time to use for _startTime.
   */
  _reset(currentTime: number = 0);

  /**
   * Create a new promise that will stop playback and emit messages for this speech.
   *
   * @param {Function=} onFinish - Funciton to execute once the speech stops.
   * @param {Function=} onError - Function to execute if the speech encounters an error.
   * @param {Function=} onInterrupt - Function to execute if the speech is canceled.
   *
   * @returns {Deferred}
   *
   * @private
   */
  _createPromise(onFinish?: any, onError?: any, onInterrupt?: any): Deferred;

  /**
   * Return whether or not the speech has reached it's end.
   *
   * @private
   *
   * @returns {boolean}
   */
  _checkFinished(): boolean;

  /**
   * Get the playback state of the audio.
   *
   * @readonly
   * @type {boolean}
   */
  get playing(): boolean;

  /**
   * Get the text of the speech.
   *
   * @readonly
   * @type {string}
   */
  get text(): string;

  /**
   * Get a shallow copy of the speechmarks array for the speech.
   *
   * @readonly
   * @type {Array.<Object>}
   */
  get speechmarks(): any[];

  /**
   * Get the number of seconds to offset speechmark emission.
   *
   * @type {number}
   */
  get speechmarkOffset(): number;

  /**
   * Set the number of seconds to offset speechmark emission.
   *
   * @type {number}
   */
  set speechmarkOffset(offset: number);

  /**
   * Get local Time.
   *
   * @type {number}
   */
  get localTime(): number;

  /**
   * Emit speechmark messages as they are encountered in sync with audio.
   *
   * @param {number} currentTime - Current global time when update was called.
   */
  update(currentTime: number);

  /**
   * Play the speech from the beginning.
   *
   * @param {number} currentTime - Current global time when play was called.
   * @param {Function=} onFinish - Optional function to execute once the speech promise resolves.
   * @param {Function=} onError - Optional function to execute if the speech encounters and error during playback.
   * @param {Function=} onInterrupt - Optional function to execute if the speech is canceled.
   *
   * @returns {Deferred} Resolves once the speech reaches the end of playback.
   */
  play(currentTime?: number, onFinish?: any, onError?: any, onInterrupt?: any): Deferred;

  /**
   * Pause the speech at the current time.
   *
   * @param {number} currentTime - Current global time when pause was called.
   */
  pause(currentTime?: number);

  /**
   * Resume the speech at the current time.
   *
   * @param {number} currentTime - Current global time when resume was called.
   * @param {Function=} onFinish - Optional function to execute once the speech promise resolves.
   * @param {Function=} onError - Optional function to execute if the speech encounters and error during playback.
   * @param {Function=} onInterrupt - Optional function to execute if the speech is canceled.
   *
   * @returns {Deferred} Resolves once the speech reaches the end of playback.
   */
  resume(currentTime?: number, onFinish?: any, onError?: any, onInterrupt?: any): any; // Deferred | null;

  /**
   * Cancels playback of the speech at the current time. Cancel the speech promise.
   */
  cancel();

  /**
   * Stop the speech and reset time to the beginning. Resolve the speech promise.
   */
  stop();
}
